노랭이 유튜브 문제풀이

3. 롤백을 하면 트랜잭션 처음으로 돌아가는데 savepoint를 해놓으면 savepoint로 감
4. 데이터 부속어 : DML명령어

6. ALTER TABLE 테이블명 ADD CONSTRAINT 제약조건명 제약조건타입 (컬럼명);
6. (오라클)ALTER TABLE 테이블명 MODIFY 컬럼명 데이터타입 NOTNULL/NULL;
6. (SQL server)ALTER TABLE 테이블명 ALTER 컬럼명 데이터타입 NOTNULL/NULL;

7.varchar(30)으로변경하는법-(1), DATE로 형변환 및 not null-(2)
(1). ALTER TABLE 테이블명 ALTER COLUMN 컬럼명 VARCHAR(30) NOT NULL; <- 원래 NOT NULL이었어도 지정해줘야함
(2). ALTER TABLE 테이블명 ALTER COLUMN 컬럼명 DATE NOT NULL;

9. ON DELETE CASCADE 외래키 삭제시 참조한 데이터도 삭제
  ON DELETE SET NULL 외래키 삭제시 외래키만 NULL로
  
11. 테이블명과 컬럼명은 문자로 시작, 사전에 정의된 예약어는 사용불가

12. INDEX: 테이블에 들리지않고 바로 가져올수있도록 따로 저장하는
	 CREATE INDEX 인덱스명 ON 테이블명 (컬럼명)

14. 외래키는 NULL값을 허용가능, 참조했기때문에 없는값을 넣을수없음 == 참조 무결성제약

16. 컬럼 삭제 == ALTER TABLE 테이블명 DROP 컬럼명
18. 테이블명 변경 == RENAME 테이블명 TO 바뀔테이블명;

19. -RESTRICT : 참조하고 있는 키가 있다면 PK를 삭제하지못함
	-AUTOMATIC : FK가 새로운 값을 INSERT할때 부모테이블에 PK를 생성
	-DEPENDENT : PK에 없는값을 FK로 설정할 수 없음

23. 로그를 남기는 키는 delete 그러나 *키를 사용할 수 없음, drop과 truncate는 로그가 안남기고 rollback이 불가능하고 자동 commit
 
24. distinct: 중복제거

27. 트랜잭션의 특성
	A-원자성: 트랜잭션에서 정의된 연산들은 모두 실행되던지 전혀 실행되지않은 상태여야함(all or nothing)
	C-일관성: 트랜잭션의 실행전 데이터베이스가 문제가 없다면 실행후에도 문제가 있으면 안됨
	I-고립성: 트랜잭션이 실행되는 도중에 다른 트랜잭션의 영향을 받아 잘못된 결과를 만들어서는 안됨
	C-자립성: 트랜잭션 성공적으로 수행시 데이터베이스에 영구적으로 저장

28. 격리성이 낮으면 생기는 문제3가지
	-dirty read: 커밋되기전에 해당 데이터를 읽는것을 말함
	-non-repeatable read: (변경된 데이터로 인해)하나의 트랙잭션내에서 같은 쿼리를 두번 수행했을때 결과가 다름
	-phantom read: (없던 레코드가 생겼을때) non-repeatable read와 같음

29. 오라클에서는 DDL문장후에는 자동으로 commit(sqlserver는 DDL이 자동 commit x)
	
32. (오라클) SAVEPOINT 세이브포인트명;		(SQL Server) SAVE TRANSACTION 세이브포인트명;
		ROLLBACK TO 세이브포인트명;				ROLLBACK TRANSACTION 세이브포인트명;
		
37. (오라클)''=> NULL			(SQL server)''=> 공백으로 인식함

42.
43. CASE 표현방식이 2가지가 있음

44. NVL(col,0) : col이 null이면 0 반환, 아니면 col 반환
	NVL2(col,1,0) : col이 null이면 0 반환, 아니면 1 반환
	ISNULL(col,0) : col이 null이면 0 반환, 아니면 col 반환
	NULLIF(col,0) : col이 0이면(col==0) null 반환, 아니면 col 반환
	COALESCE(col1, col2, col3) : null이 아닌 첫번째 값 반환
 
52.

63. JOIN
	-DBMS 옵티마이져는 특정 2개의 테이블을 JOIN하고 나머지 테이블을 JOIN함
	-EQUI JOIN은 같은 값을 기준으로 데이터가 조회됨
	-부등호를 쓰거나 BETWEEN을 쓰면 NON EQUI JOIN이라고 한다. 

65. 순수관계연산자9ㅡ 
	-SELECT(수평연산)
	-PROJECT(수직연산)
	-JOIN
	-DIVISION
	
66. TO_CHAR(SYSDATE,'YYYY.MM.DD')(문제집보고 다시풀기)
	LEFT OUTER JOIN: 기준테이블은 모두 나오고 JOIN 되어서 해당하는 것만 나옴

67. 카티시안곱(Cartesian Product): 발생가능한 모든 경우의 수의 행이 출력되는 것
	== cross join
	
69. from절에 조인 조건이없으면 신텍스 오류
	brtween join은 없음

70. (오라클)using: on이 아닌 using은 같은 컬럼 하나만 적으면 됨('=' 필요없음)
  	
73. full outer join: join 수행시 좌측 우측 테이블의 모든 데이터를 읽어 join함

77(!). 오라클에서 +는 outerjoin이며 +가 안붙은 쪽이 기준이 됨(
	
79. union: 결과의 합집합으로 중복된 행은 하나의 행으로 만듬
	union all: union에서 중복된행도 그대로 결과에 표시함
	intersect: 결과의 교집합으로 중복된 행은 하나의 행으로 만듬
	except: 앞에 결과에서 except 뒤의 결과에 대한 차집합 == minus
	
82. union all을 사용하면 select 첫번째 컬럼 별칭을 따라감

87(이게 뭔 소리지). prior: 
	
88. 루트node의 level값은 0

94. A||B == A+B

95. 서브쿼리는 단일행 또는 복수행 비교연산자와 함께 사용할 수 있다.
	서브쿼리는 select절, from절, having절, order by절에서 사용가능
	연관 서브쿼리: 쿼리문에 메인쿼리 컬럼이 포함하고 있는 형태
	다중컬럼서브쿼리는 메인쿼리와 동시에 비교되는것을 의미하며 오라클에서만 가능
	
96. <> == 같지않은것

98. group by가 안와도 having절 올 수 있음 

99. 단일행도 in과 같은 비교연산자를 사용가능

100. from절 서브쿼리 == 인라인뷰
	 select절 서브쿼리 == 스칼라서브쿼리 => join으로도 동일한 결과 추출가능

104. 뷰생성 스크립트 형식
	CREATE VIEW 뷰테이블명
	AS
	SELECT *
	FROM 테이블명
	WHERE 조건절
	
ROLLUP, CUBE, GROUPRING SETS
 ROLLUP: ROLLUP에 들어온 인자를 오른쪽부터 하나씩 빼면서 GROUPING함
 CUBE: 모든 경우의수가 다 나옴(컬럼의 순서가 수행결과에 영향을 미치지않음)
 GROUPING SETS(COL1,CO2): 결과1: COL1		지정한 형식대로 나옴
 						  결과2: COL2 

105번 이해안됨

윈도우 함수: SELECT결과에 대하여 행과 행간의 관계를 파악, 행수는 변화 없음
	형식 => 윈도우함수() OVER (PARTITION BY 컬럼 ORDER BY 컬럼 ASC/DESC)
	★-순위함수:ROW_NUMBER(12345),RANK(12245),DENSE_RANK(12234)
	★-집계함수:COUNT,SUM,MAX,MIN,AVG
 		-행의 순서함수:LAG(이전값),LEAD(다음행)
 		-비율함수 
	EX) SELECT *,RANK() OVER(ORDER BY 매출액 DESC) AS 순위
	EX) SELECT *,SUM(집계컬럼) OVER(PARTITION BY A.고개번호, A.고객명 [ORDER BY ASC/DESC]) AS 누적합계
	RANGE BETWEEN(PARTITION범위 기준으로 계산) , ROW BETWEEN(행기준으로 계산)

권한 부여
	GRANT: 유저에게 개체에 대한 권한을 허용
	DENY: 유저에게 개체에 대한 권한을 차단
	REVOKE: 유저에게 부여된 권한을 회수
	EX)	GRANT SELECT ON SCHEMA::A_User TO 유저명
		REVOKE SELECT ON SCHEMA::A_User TO 유저명
		DENY SELECT ON SCHEMA::A_User TO 유저명
		DENT SELECT ON A_User.TABLE1 TO 유저명
	ROLE: 다양한 권한을 그룹으로 묶어 관리할 수 있도록 사용자와 권한 사이에서 중개역할을 수행
	
PL/SQL: sql을 확장한 절차적인 언어
		-종류: 프로시져/함수/트리거
		절차적 코드: 예외처리,루프,커밋,롤백 등 procedure엔진이 처리함
		오라클같은 경우에는 그냥 쓰면 안됨
		=> execute immediate
		trigger는 tcl(commit,rollback,savepoint)을 이용할 수 없다.

옵티마이저: db내부의 핵심엔진 (규칙기반옵티마이져, 비용기반옵티마이져)
규칙기반 옵티마이져: 우선순위가 높은 규칙을 기준으로 sql을 작동
비용기반 옵티마이져: 가장 효율적인 것으로 예상되는 실행계획을 선택해서 작동
실행계획: 액세스기법, 조인기법(조인순서) , 최적화정보(비용)
	=> SQL처리를 위한 실행 절차와 방법을 표현한 것이디. 
SQL처리 흐름도 == 실행계획의 실행방식을 시각화한것

인덱스:
	- B-TREE 인덱스(보조인덱스): ROOT-> BRANCH-> LEAF-> TABLE
	- 클러스터 인덱스(기본인덱스): LEAF가 데이터 저장공간 PK기준으로 정렬되어있음
		CREATE UNIQUE INDEX
		CREATE INDEX
	- 비트맵 인덱스: 용량을 적게 차지, 대용량 테이블에 유용
 
조인 방식
	-NL방식: 칼럼순서 중요, 인덱스있으면 유리, 소량테이블 조회시 유리, DRIVING TABLE, EQUI조인조건 
	-SORT MERGE방식: 데이터를 정렬 후 조인, 디스크로인해 성능이 떨어질 수도 있음
	-HASH방식: HASHMAP
SQL문에서는 EXISTS 사용하면 옵티마이져는 SEMI JOIN 사용여부판단
		NOT EXISTS 사용하면 ANTI JOIN 사용여부
		







